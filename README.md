# koa-ssr

[Koa]: http://koajs.com
[JSDOM]: https://github.com/tmpvar/JSDOM

Use [JSDOM] to evaluate (and cache) your client-side app on server before serving response as HTML in [Koa].

Perfect for serving static content generated by webpack production build.

# Install

```bash
npm i koa-ssr
```

# Usage

```js

import Koa from 'koa';
import koaStatic from 'koa-static';
import koaSSR from 'koa-ssr';

const app = new Koa();

const root = __dirname + '/dist'

// serve static content as usual:
app.use(koaStatic(root, {
  // DON'T let index.html be served statically
  index: false  // << important!
}))

app.use(koaSSR(root, {
  // we'll (re-)generate it here
  index: 'index.html'
}))

```

## API

```
koaMiddleware = koaSSR(root, opts)
```

* **`root`** root directory
* **`opts`** options:

### Options

* **`index`** (default: **`'index.html'`**) Main index file
* **`html`** Instead of index.html, provide an html string
* **`timeout`** (default: **`5000`**) After which if JSDOM hasn't finished loading (i.e. `window[opts.modulesLoadedEventLabel]` hasn't been called (see below)) it throws an error (with `{ koaSSR: {ctx, window} }` property attached).

* **`cache`** `[bool|obj|function]` \(default: **`true`**) Whether (and where/how) to cache JSDOM responses
  * **`false`** Doesn't uses a cache, JSDOM is run for every request
  * **`true||{}`** Uses an object (created or provided) to store JSDOM generated response as <code><strong>{</strong>url: body<strong>}</strong></code>
  * **`function`** Calls the function `cache(ctx, [body])` either with `body` as second argument or without it in which case expects it to be returned and used as a response. Eg.:

    ```
      koaSSR(root, {
        cache: (ctx, body) => {
          if (body) {
            // store
            cache[ctx.url] = body
          } else {
            // return
            return cache[ctx.url]
          }
        }
      })
    ```

* **`console`** (default: modified [debug]) `console` object for [JSDOM's `virtualConsole`](https://github.com/tmpvar/jsdom/#capturing-console-output) used as <code>jsdom.createVirtualConsole().sendTo(<strong>console</strong>)</code>

* **`jsdom`** [Config](https://github.com/tmpvar/jsdom/#how-it-works) passed to JSDOM: <code>jsdom.jsdom(opts.html, <strong>opts.jsdom</strong>)</code>. Eg. for [shimming unimplemented APIs](https://github.com/tmpvar/jsdom/#shimming-unimplemented-apis):

    ```
      koaSSR(root, {
        jsdom: {
          created: (e, window) => {
            window.localStorage = new MockLocalStorage();
          },
        }
      })
    ```

* **`modulesLoadedEventLabel`** (default: **`'onModulesLoaded'`**) A special function is attached to `window[modulesLoadedEventLabel]` which \*\***must be called**\*\* to indicate that your app has finished rendering. Failure would result in a timeout and an error thrown (with `{ koaSSR: {ctx, window} }` property attached). See [JSDOM: Dealing with asynchronous script loading](https://github.com/tmpvar/jsdom/#dealing-with-asynchronous-script-loading) as to why you need this instead of relying on default `onload` or other such events. This can also be used as an indicator that your app is being rendered server-side so you may choose to deal with that aspect in your app as well.

    Eg.

    **`server.js`**

    ```
      koaSSR(root, {...})
    ```

    **`client-app.js`**

    ```
      import {h, render} from 'preact'

      if (!window.onModulesLoaded) {
          // not rendered on server
          const data = await localStorage.get('session')
      }

      render(h('div', {...data}, ['Hello world!']), document.body)

      if (window.onModulesLoaded) {
          // rendered on server
          window.onModulesLoaded();
      }
    ```



[debug]: https://www.npmjs.com/package/debug
